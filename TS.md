**Задача 2.3. UnorderedMap.**

**Дедлайн: 10 мая 23:59 мск**

В этой задаче Вам предлагается реализовать упрощенный аналог одного из популярных контейнеров STL - unordered\_map&#39;а. Для этого Вам пригодится List, написанный ранее. Кроме того, в вашем контейнере нужно будет правильно поддержать нужные виды итераторов, работу с аллокатором и **move-семантику**.

**Использовать std::list в этой задаче нельзя. Необходимо пользоваться своим.**

Напишите шаблонный класс UnorderedMap\&lt;Key, Value, Hash, Equal, Alloc\&gt; - упрощенный аналог std::unordered\_map.

Здесь Key - тип ключа, Value - тип значения, Hash - используемая хеш-функция (по умолчанию std::hash<Key>, реализовывать hash не надо), Equal - используемый сравниватель (по умолчанию - std::equal_to<Key>), Alloc - используемый аллокатор (по умолчанию - std::allocator<std::pair<const Key, Value>>).

**Типы Key и Value не обязаны иметь конструкторы по умолчанию, копирующий конструктор и копирующий оператор присваивания. Для создания UnorderedMap с ними должно быть достаточно, чтобы они имели лишь move-конструктор и move-оператор присваивания.**

Внутри UnorderedMap публично определим тип NodeType как std::pair<const Key, Value>. (В std::unordered_map аналогичный тип называется value_type.)

Должна быть реализована следующая функциональность:

- Конструкторы (в т.ч. копирования и перемещения), деструктор, копирующий и перемещающий операторы присваивания.
- Методы [] и at(key), работающие в среднем за O(1). Метод [] определен только для неконстантных объектов, он создает Value по умолчанию, если по данному ключу ничего не было. Метод at(key) в таком случае кидает исключение.
- Метод size(), за O(1) возвращающий текущее количество элементов в контейнере.
- Внутренние типы Iterator и ConstIterator, удовлетворяющие требованиям ForwardIterator. Разыменование константного итератора не должно позволять поменять объект под ним.
- Методы begin(), end(), cbegin(), cend().
 Данные методы должны быть реализованы так, чтобы код
  for (auto it = m.begin(); it != m.end(); ++it); позволял пройтись по всем лежащим в контейнере элементам **за линейное время от количества этих элементов. Инкрементация любого итератора должна происходить за гарантированное O(1).**
- Метод insert, принимающий ссылку на NodeType и возвращающий pair\&lt;Iterator, bool\&gt;, где bool означает &quot;произошла ли вставка&quot;, а Iterator указывает на элемент с данным ключом в контейнере (либо уже лежавший там, либо только что вставленный). **Метод insert должен эффективно обрабатывать как lvalue, так и rvalue: не копировать переданную ему NodeType, если она была rvalue!** Вставка элемента должна работать за O(1) в среднем.
- Метод insert от пары InputIterator&#39;ов на NodeType, делающий вставку всего данного диапазона в контейнер.
- **Итераторы на элементы мэпа не должны инвалидироваться при insert, если при этом не произошел rehash. Ссылки на элементы мэпа не должны инвалидироваться при insert, даже если rehash произошел.**
- Метод emplace(Args&amp;&amp;... args), который самостоятельно конструирует NodeType от переданных аргументов (без их копирования, если это возможно) и, не копируя, вставляет полученный объект NodeType в контейнер, если это возможно. Возвращаемый тип - такой же, как у insert от NodeType. **Конструировать NodeType нужно с помощью правильного аллокатора (то есть Alloc, если он был указан, а точнее, через allocator\_traits от него)!**
- Метод erase от итератора, а также от пары итераторов (удаляющие один элемент и диапазон элементов соответственно). Итераторы на элементы, которые не были удалены, должны не инвалидироваться после вызова erase. Удаление одного элемента должно работать за O(1) в среднем.
- Метод find по ключу, возвращающий итератор на найденный элемент или end(), если элемент не был найден. Поиск должен работать в среднем за O(1).
- Методы reserve, max\_size, load\_factor и max\_load\_factor, аналогичные методам STL, позволяющие управлять размером хеш-таблицы.