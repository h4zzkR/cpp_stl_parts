**Задача 2.5. Function**

**(дедлайн – конец зачетной недели)**

Напишите класс Function – упрощенный аналог std::function из C++11.

Тип `Function<ReturnType(Args...)>` должен уметь хранить объект любого типа T, который является Callable от типов Args… с возвращаемым значением типа ReturnType. Формальное определение Callable написано [здесь](https://en.cppreference.com/w/cpp/named_req/Callable).

В качестве хранимого в Function объекта может выступать любое из следующего:

• Указатель на C-style функцию;

• Обычный функциональный объект (т.е. объект, обладающий оператором () с соответствующими типами аргументов);

• Замыкание (то есть объект, созданный лямбда-выражением);

В этой задаче от вас требуется реализовать Function приближенно к тому, как это сделано в STL, а именно – запрещено использовать виртуальные функции. Посылки, в коде которых присутствует ключевое слово virtual, будут игнорироваться.

Подсказка по реализации: заведите внутренний класс Manager с шаблонным параметром F (тип функтора), в котором определите статические методы на каждое возможное действие с функтором. В своем классе Function храните указатели на эти методы (точнее, указатель на один метод с дополнительным параметром OperationType, с помощью которого можно выбирать нужный метод). (По сути, в каком-то смысле это упрощенная реализация механизма виртуальных функций своими руками.)

Класс Function должен обладать следующей функциональностью:

• Конструктор по умолчанию;

• Конструктор от Callable-объекта. Объект должно быть можно отдать в этот конструктор как в виде lvalue (и тогда Function должна скопировать его содержимое в себя), так и в виде rvalue (тогда Function должна мувнуть в себя его содержимое). Если принятый объект не является Callable с нужными аргументами, попытка создать Function от него должна приводить к CE.

• Конструктор копирования, конструктор перемещения, операторы присваивания (copy и move), деструктор.

• Оператор () с соответствующими аргументами, позволяющий вызвать хранимый в Function объект как функцию. Если там сейчас не хранится никакого объекта, нужно бросить исключение.

Кроме того:

• Function должна быть легковесным объектом. А именно, sizeof(Function) должен не превосходить 32 байт (ибо sizeof(std::function) в контесте именно такой).

• Предыдущий пункт означает, что если Callable-объект, который нужно сохранить в Function, достаточно большой, то под него надо выделять динамическую память. Это можно делать напрямую с помощью new/delete, аллокатором в этой задаче пользоваться необязательно.

• Обращения к new/delete надо по возможности экономить. Если новый Callable-объект можно положить на то же место, где лежал старый, то не надо делать перевыделение памяти.

• Для основного потока: Если Callable-объект достаточно мал по размеру (не превосходит 16 байт), то динамическая память под него выделяться не должна! Такие объекты Function должна уметь хранить внутри своих полей, т.е. на стеке.